//====================================
//一般ttys的设备都是动态分配


//注册驱动
uart_register_driver{ 
- 初始化驱动中的tty_driver normal，设置驱动名，波特率...
- 初始化uart_driver->state,tty_port_init{//驱动中支持的最大端口数
	- 
	}
- 注册串口驱动，tty_register_driver{
		- 请求字符设备号alloc_chrdev_region() //一般driver名为"ttyS"
		- tty_cdev_add{
			- cdev_alloc
			- 设置操作函数driver->cdevs[index]->ops = &tty_fops
			- cdev_add
			}
		- list_add(&driver->tty_drivers, &tty_drivers) //加入tty_driver
		- 注册proc信息，proc_tty_register_driver
	}tty_io.c
- tty_port_destroy
- put_tty_driver
}@serial_core.c

//加入端口
uart_add_one_port(struct uart_driver *drv, struct uart_port *uport)@serial_core.c-->
tty_port_register_device_attr{
- tty_port_link_device
- tty_register_device_attr{
	- 若是非动态创建，tty_cdev_add //一般动态创建
	- 创建并初始化struct device
	- device_register
	}@tty_io.c
}@tty_port.c





//收到一个字符
uart_insert_char@serial_core.c-->tty_insert_flip_char@tty_flip.h

tty_flip_buffer_push
======================
TTY设备：

console_init@tty_io.c-->tty_ldisc_begin-->tty_register_ldisc(N_TTY, &tty_ldisc_N_TTY)@tty_ldisc.c

//open
tty_fops.open-->tty_open{
- struct tty_struct *tty //主要初始化这个
- 若设备是TTYAUX_MAJOR。则获取对应的驱动 //一般不走这个流程
- 获取设备对应的tty_driver，tty_lookup_driver-->get_tty_driver{//普通ttyS流程
	- 遍历tty_drivers中的驱动，返回设备号相同的struct tty_driver
	}@tty_io.c
- 根据tty_driver查找tty设备，tty_driver_lookup_tty
- 没有找到，初始化一个tty设备，tty_init_dev{
		- 分配设置tty，alloc_tty_struct-->tty_ldisc_init-->tty_ldisc_get(N_TTY){
			- ldops = get_ldops-->tty_ldiscs[disc] //获取操作函数 tty_ldisc_N_TTY
			- ld = kmalloc(sizeof(struct tty_ldisc)
			- ld->ops = ldops
			}@tty_ldisc.c
		- 将tty设置到对应驱动中，tty_driver_install_tty-->(设置串口配置)tty_init_termios
		- tty_ldisc_setup
		}
- 关联tty结构和被打开文件，tty_add_file
}@tty_io.c

//read
tty_fops.read-->tty_read{
- ld = tty_ldisc_ref_wait(tty)-->tty->ldisc
- ld->ops->read-->n_tty_read@n_tty.c
}@tty_io.c


======================
//写入数据并传送
tty_fops.write-->tty_write{
- 获取tty_ldisc设备，tty_ldisc_ref_wait(tty)
- 通过tty_ldisc操作，do_tty_write-->ld->ops->write
}@tty_io.c



======================
//收到数据并读取
tty_struct.buf

tty_insert_flip_char(struct tty_struct *tty){//将读取的数据保存到buffer
- struct tty_buffer *tb = tty->buf.tail //获取bufer
- tb->char_buf_ptr[tb->used++] = ch //若buffer有空间保存数据到buffer中
- tty_insert_flip_string_flags{//现有空间不够
	- tty_buffer_request_room-->tty_buffer_find //调整buffer大小
	- memcpy //将数据拷贝到buffer中
	}
}@tty_buffer.c

tty_flip_buffer_push{
- tty->buf.tail->commit = tty->buf.tail->used
- flush_to_ldisc{ //低延时
	- count = head->commit - head->read //当前buffer中的数据数量
	- disc->ops->receive_buf-->n_tty_receive_buf{
		- 
		}@n_tty.c
	}
- schedule_work-->flush_to_ldisc //高延时
}@tty_buffer.c



kernel/drivers/tty/tty_io.c
kernel/drivers/tty/serial/serial_core.c
kernel/include/linux/tty_flip.h
kernel/drivers/tty/tty_ldisc.c
kernel/drivers/tty/n_tty.c
kernel/drivers/tty/tty_port.c
