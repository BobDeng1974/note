//tinymix -D 1/2/3 查看sprdphone对应的声卡是哪个
tinycap /data/afe_in.wav -D 3 -d 2 -c 2 -r 48000 -p 320 -n 2

echo 6 > /proc/sys/kernel/printk
echo 1 > /proc/sys/kernel/printk
echo 4 > /proc/sys/kernel/printk &
echo -n 1  > /sys/fytver/resetGPS
echo -n 0  > /sys/fytver/resetGPS
//mainmic
/proc/asound/sprdphone/pcm0c/info

//auxmic 默认多媒体mic
/proc/asound/sprdphone/pcm2c/info


adb shell cat /proc/asound/sprdphone/sprd-codec > sprd-codec.txt
adb shell cat /proc/asound/sprdphone/vbc > vbc.txt
adb shell cat /proc/asound/sprdphone/pcm2c/DMA > dma.txt

cat /proc/asound/sprdphone/pcm2c/sub0/hw_params
cat /proc/asound/sprdphone/pcm2c/sub0/sw_params
cat /proc/asound/sprdphone/pcm2c/sub0/status
cat /proc/asound/sprdphone/pcm2c/sub0/info
cat /proc/asound/sprdphone/pcm2c/info

dd if=/storage/USB0/boot.img of=/dev/block/platform/sdio_emmc/by-name/boot bs=1024 count=16000
dd if=/sdcard/boot.img of=/dev/block/platform/sdio_emmc/by-name/boot bs=1024 count=16000

61      BOOL    1       ADC1-DAC Digital Loop switch             Off
62      BOOL    1       ADC-DAC Digital Loop switch              Off
63      BOOL    1       ADC1-DAC Adie Loop switch                Off
64      BOOL    1       ADC-DAC Adie Loop switch                 Off
tinymix -D 3  61 1
tinymix -D 3 63 1
//查看设备
cat proc/asound/devices

//声卡状态
/proc/asound/card0/pcm0p/sub0
cat hw_params
cat sw_params

//抓取dump
adb root
setprop media.dump.path /data/local/media/ 
setprop media.dump.switch 0x300
//media播放
setprop media.dump.switch 0x3 


//设备
tinymix -D 0

tinymix -D num "SPKL Mixer DACLSPKL Switch" 1 
tinymix -D num "SPKL Mixer DACRSPKL Switch" 1
tinymix -D num "Speaker Function" 1



logcat -s MediaPlayerFyt audio_hw_primary
logcat -s DUMP.DATA
logcat -s audio_hw_primary


//audioDebug apk
setenforce 0


<dumpmusic  num="16"  dump_switch = "0x0" dump_path="/data/local/media/" total_switch="ON">
	<dump_play  index="0" item_name ="music.dump0"  dump_file_name ="dump_music_before_express.pcm"  switch="0" />
	<dump_play  index="1" item_name ="music.dump1"  dump_file_name ="dump_music_before_vbc.pcm"  switch="0" />
	<dump_play  index="2" item_name ="music.dump2"  dump_file_name ="dump_mix_vaudio.pcm"  switch="0" />
	<dump_play  index="3" item_name ="music.dump3"  dump_file_name ="dump_voip_write.pcm"  switch="0" />
	<dump_play  index="4" item_name ="music.dump4"  dump_file_name ="dump_bt_sco_write.pcm"  switch="0" />

	<dump_record index="8" item_name ="record.dump0" dump_file_name ="dump_record_after_vbc.pcm" switch="0" />
	<dump_record index="9" item_name ="record.dump1" dump_file_name ="dump_record_after_express" switch="0" />
</dumpmusic>

//蓝牙声音
    加入车载蓝牙补丁

diff --git a/idh.code/vendor/sprd/modules/audio/normal/at_commands_generic.c b/idh.code/vendor/sprd/modules/audio/normal/at_commands_generic.c
index 0c83e2c..158cbc8 100644
--- a/idh.code/vendor/sprd/modules/audio/normal/at_commands_generic.c
+++ b/idh.code/vendor/sprd/modules/audio/normal/at_commands_generic.c
@@ -89,6 +89,16 @@ static void do_voice_command(struct tiny_audio_device *adev)
     ALOGE("do_voice_command: X");
 }
 
+static void do_voice_command_direct(const char * at_cmd)
+{
+    int ret;
+#ifdef ANDROID5X
+    ret = sendAt(st_vbc_ctrl_thread_para->adev->cp_type, android_sim_num, at_cmd);
+#else
+    ret = sendCmd(android_sim_num, at_cmd);
+#endif
+    ALOGD("do_voice_command_direct: X:%d", ret);
+}
 static void voice_command_signal(struct tiny_audio_device *adev,const  char* at_cmd,int index)
 {
     ALOGV("voice_command_signal: E");
diff --git a/idh.code/vendor/sprd/modules/audio/normal/audio_hw.c b/idh.code/vendor/sprd/modules/audio/normal/audio_hw.c
index 327c446..be1d81d 100644
--- a/idh.code/vendor/sprd/modules/audio/normal/audio_hw.c
+++ b/idh.code/vendor/sprd/modules/audio/normal/audio_hw.c
@@ -706,6 +706,7 @@ struct tiny_private_ctl private_ctl;
     char* cp_nbio_pipe;
     struct mixer *i2s_mixer;
     int i2sfm_flag;
+    int hfp_start;
 #ifdef NXP_SMART_PA
     fm_handle fmRes; //for smartpa fm
     nxp_pa_handle callHandle;//for smartpa call
@@ -4966,6 +4967,18 @@ static int adev_set_parameters(struct audio_hw_device *dev, const char *kvpairs)
               fm_gain |= fm_headset_volume_tbl[i]<<16;
               SetAudio_gain_fmradio(adev,fm_gain);
            }
+         }
+    }
+    ret = str_parms_get_str(parms, "hfp_enable", value, sizeof(value));//add for bt client,withch iis channel
+    if( ret >= 0 ){
+        if(strcmp(value, "true") == 0) {
+            char *at_cmd = NULL;
+            at_cmd="AT+SPTEST=31,1";
+            do_voice_command_direct(at_cmd);
+        } else if (strcmp(value, "false") == 0) {
+            char *at_cmd = NULL;
+            at_cmd="AT+SPTEST=31,0";
+            do_voice_command_direct(at_cmd);
         }
     }
 
diff --git a/idh.code/vendor/sprd/modules/audio/normal/vb_control_parameters.c b/idh.code/vendor/sprd/modules/audio/normal/vb_control_parameters.c
index 4749133..97bf964 100644
--- a/idh.code/vendor/sprd/modules/audio/normal/vb_control_parameters.c
+++ b/idh.code/vendor/sprd/modules/audio/normal/vb_control_parameters.c
@@ -962,6 +962,11 @@ int SetParas_OpenHal_Incall(struct tiny_audio_device *adev, int fd_pipe)   //Get o
         ALOGE("Error, read %s ret(%d) failed(%s).",__func__,ret,strerror(errno));
     }
     android_sim_num = hal_open_param.sim_card;
+    if(android_sim_num&0x100) {
+        android_sim_num&=~0x100;
+        adev->hfp_start = 1;
+        ALOGI("Open hal device do as hfp!");
+    }
     MY_TRACE("%s successfully,sim card number(%d)",__func__,android_sim_num);
     return ret;
 }
@@ -1985,6 +1990,15 @@ RESTART:
                    else if( adev->cp_type == CP_CSFB)
                        i2s_pin_mux_sel(adev,CP_CSFB);
                }
+               if(adev->hfp_start){
+                   FILE * i2s_ctrl;
+                   char * i2s_ctrl_value="1";
+                   i2s_ctrl = fopen("/proc/pin_switch/iis0_sys_sel/cp1_iis0","wb");
+                   if(i2s_ctrl != NULL) {
+                       fputs(i2s_ctrl_value,i2s_ctrl);
+                       fclose(i2s_ctrl);
+                   }
+               }
                voip_forbid(adev, true);
                adev->call_start = 1;
                if (adev->cache_mute = 1) {
@@ -2030,6 +2044,17 @@ RESTART:
 
                vbc_call_end_process(adev,false);
                MY_TRACE("voice:VBC_CMD_RSP_CLOSE IN.");
+               if(adev->hfp_start) {
+                   FILE * i2s_ctrl;
+                   char * i2s_ctrl_value="1";
+                   ALOGI("set hfp_start to 0!");
+                   i2s_ctrl = fopen("/proc/pin_switch/iis0_sys_sel/ap_iis0","wb");
+                   if(i2s_ctrl  != NULL) {
+                       fputs(i2s_ctrl_value,i2s_ctrl);
+                       fclose(i2s_ctrl);
+                   }
+                   adev->hfp_start = 0;
+               }




===========
16k采样率下。80ms的数据重复。16 x 80=160 x 8=1280 words



channels: 2
rate: 16000 (16000/1)     16000 frames/s
period_size: 320 frame    1280 bytes  20ms
buffer_size: 960 frame    3840 bytes  60ms
boundary: 2013265920      


//
[ 1226.371002] c0 :5  interrupt:0 hw:5655840 new:5656640 pos:320 base:5656320 ptr_base:5655360 fyt1:0 fyt2:1
new_hw_ptr < old_hw_ptr=runtime->status->hw_ptr
(ptr_base + pos)5655360 + 320= 5655680 < 5655840 //why
5656640-960 = 5655680 //新指针增加一个buffer_size 

//DMA
FULL_CHN_PAUSE	  FULL_CHN_REQ	     FULL_CHN_CFG	FULL_CHN_INT

FULL_CHN_SRC_ADDR FULL_CHN_DEST_ADDR FULL_CHN_FRAG_LEN  FULL_CHN_BLK_LEN

FULL_CHN_TRSC_LEN FULL_CHN_TRSF_STEP FULL_CHN_WRAP_PTR  FULL_CHN_WRAP_TO

FULL_CHN_LLIST_PTR FULL_CHN_FRAG_STEP FULL_CHN_SRC_BLK_STEP FULL_CHN_DEST_BLK_STEP
