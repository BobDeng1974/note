========================
包名要和当前文件夹对应。不指定类所在的包时，类处在当前文件夹下的默认包中。

类的权限修饰只有缺省和public（内部类可使用private）。缺省在同一个包中可用，public所有其他类可用。
类中域和方法的修饰
private，只有该类可用
protect，继承可用，其实是用来导出部分接口给包外的类
缺省，同一包中可用(其实结合类的权限修饰，默认的都是在同一个包中可用)
public，所有可用

每个类都可以有main函数，执行main函数通过java xxx。

类的复用：(使用已有类的域或方法)
两种形式：
组合是类中包含要使用的类(作为一个域，只能使用类中已有和已允许使用的方法和域)
继承是新类继承自父类(可以方法重载，重写)

数据；
1，永不改变的值，编译期常量(final 必须在定义时赋值)
2，运行期初始化的值，在运行时不希望改变

final方法 1，不会被继承的类改变(设计角度) 2，在编译阶段会将对该方法的调用转为内嵌调用

private修饰的域，方法默认是final

final类不会被继承，被改变

========================
容器：
Map:键值对的集合，键值类型在map声明时确定。
hashmap操作没有实现同步（要自己实现多线程操作），hashtable可以同步操作

Set:集合，不允许有重复的项
获取的方法是遍历，Iterator.next
List:像数组，每个项都有编号（从0开始）

========================
异常：
exception 继承 Throwable:
抛出异常：throw ception{}
异常说明：说明某个方法会抛出异常（程序发布后不会公布代码，在api中可说明。使调用者捕获异常）
捕获异常：try{语句块}catch（exception e）{...}finally{...}

method throws Exception{}

3种类型的异常：
1.checked exception 被程序捕获和处理的异常，程序能够继续执行。
2.error 不是由程序引起，（如：硬件或系统错误），程序不能够继续执行
3.runtime exception 由逻辑错误引起。程序不能够预测到，不能继续执行。

error和runtime exception属于unchecked exception

________________________
捕获异常：
try { return x; } finally { ... } //finally中语句一定会被执行，实际上finally语句编译在try中return之前

========================
线程池：


========================
内部类包括匿名类(anonymous): 

匿名类访问外部类变量必须是final，因为匿名类保存了外部类成员的拷贝，而不是直接访问外部类成员。
如果不是final类型，匿名类执行的结果会很奇怪(外部类成员会变化，而内部类访问的值不变)。


=======================
annotation(注释语言)
注释为程序提供数据，但并不直接影响程序。

Information for the compiler — 编译器使用注释查找编译是的错误或警告
Compile-time and deployment-time processing — 其他工具可以根据注释产生代码或文件(jdoc)
Runtime processing — 一些注释是变量，能够在程序运行时被检查
